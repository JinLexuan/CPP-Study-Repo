# Tracking Memory Allocation
A little tool to track memory
``` cpp
#include <iostream>

struct AllocationMetrics
{
    int32_t totalAllocated = 0;
    int32_t totalFreed = 0;
    
    int32_t getCurrentUsage()
    {
        return this->totalAllocated - this->totalFreed;
    }
};

static AllocationMetrics memoryTracker;

void* operator new(std::size_t size)
{
    memoryTracker.totalAllocated += size;
    return malloc(size);
}

void operator delete(void* memory, std::size_t size)
{
    memoryTracker.totalFreed += size;
    free(memory);
}

void printMemoryUsage()
{
    std::cout << "Memory used: " << memoryTracker.getCurrentUsage() << "byts\n";
}
```

# Lvalues and Rvalues
Rvalue cannot be assigned with value. Lvalue has location in memory.
The following example is feasible because it returns a reference of lvalue.
``` cpp
int& getValue()
{
    static int value = 10;
    return value;
}

int main()
{
    int i = getValue();
    getValue() = 5;
}
```

A  rvalue is not allowed to be assigned to a lvalue reference. In another word, can only have lvalue reference of a lvalue.
``` cpp
void setValue(int& i)
{
}

int main()
{
    int i = 10;
    setValue(i);
    setValue(10); // This is not allowed
}
```

A special rule: rvalue can be assigned to const lvalue reference.
``` cpp
const int& i = 10;
```

Use lvalue reference to check one value is lvalue or rvalue.
``` cpp
void printName(std::string& name)
{
    
}

int main()
{
    std::string firstName = "aasdas";
    std::string lastName = "ajhfalfkldfjds";
    std::string fullName = firstName + lastName;
    
    printName(fullName);
    printName(firstName + lastName);  // This is not allowed, because it is a rvalue.
    // Solution: add const to name in printName()
}
```

&&: rvalue reference, only receive temporary object.
``` cpp
void printName(std::string&& name)
{
    
}

int main()
{
    std::string firstName = "aasdas";
    std::string lastName = "ajhfalfkldfjds";
    std::string fullName = firstName + lastName;
  
    printName(fullName); // This is not allowed, because it is a lvalue.
    printName(firstName + lastName);
}
```

The following code can be used to check whether it is 
``` cpp
void printName(const std::string& name)
{
    std::cout << "[lvalue]" << std::endl;
}

void printName(std::string&& name)
{
    std::cout << "[rvalue]" << std::endl;
}

int main()
{
    std::string firstName = "aasdas";
    std::string lastName = "ajhfalfkldfjds";
    std::string fullName = firstName + lastName;
    
    printName(fullName); // This is not allowed, because it is a lvalue.
    printName(firstName + lastName);
}
```

## Continous Integration
